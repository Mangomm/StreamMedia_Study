RTSP这节好像都是使用ZLM作为服务器，SRS不用，因为SRS不支持RTSP。

1：
就讲了搭建ZLM和测试rtsp，rtmp的推流，拉流。并且测试rtsp使用了tcp推流，用tcp、udp的拉流是否支持。udp同理测试。

rtsp推tcp、udp流(都支持推流，并且也支持下面的各种拉流)：
ffmpeg -re -i "/e/code/day-20-rtsp/time.flv" -vcodec h264 -acodec aac -f rtsp -rtsp_transport tcp rtsp://192.168.1.9/live/test	
ffmpeg -re -i "/e/code/day-20-rtsp/time.flv" -vcodec h264 -acodec aac -f rtsp -rtsp_transport udp rtsp://192.168.1.9/live/test	

rtsp拉流：
ffplay -rtsp_transport tcp rtsp://192.168.1.9/live/test
ffplay -rtsp_transport udp rtsp://192.168.1.9/live/test	//udp比较快

rtmp拉rtsp推的流：
ffplay rtmp://192.168.1.9/live/test	//可以播放

关于其它方式(h265、rtp等等)推流就不测了。注意我ffmpeg没有支持h265，所以会报错--Unknown encoder 'h265'。
。

2-RTSP基本原理(全部听懂了)：
1）这里首先讲了RTSP由什么组成的，看2的png的第1点RTSP组成原理的那两幅图即可。
2）然后讲了如何抓rtsp、rtp、rtcp、sdp的包，推流然后抓即可，抓包命令为rtsp or rtp or rtcp，推流命令用上面的即可。
3）然后推流rtsp在指定TCP、UDP的方式下对比RTSP、RTCP、RTP(包括音频、视频的端口)，分别对TCP、UDP推流方式下进行抓包有：
rtsp的端口不管tcp还是udp，都只占用配置好的554端口。而在TCP下，RTCP视频、RTCP音频、RTP视频、RTP音频也是占用一个端口，并且也是554.
但是在UDP下，RTCP在音视频各自占1个，是独立的，RTP也是音视频各自一个，也是独立的。
4）然后讲到客户端如何知道我服务器要用哪个RTCP、RTP各自音视频的端口。并且需要注意UDP方式拉流RTSP时，由于开放的端口多，所以实际商用拉流不
能播放时需要注意对应的端口是否开放了。
5）然后讲了96为何是视频，97为何是音频，需要去看抓出来ANNOUCE的包。
5）然后讲了课程的重点，RTP、SDP是最重要的。
具体对着看2-png即可，非常详细了，2-pdf实际和png重复了，可以不看。

3-RTP协议讲解：
1）这节课主要讲了RTP的头部，首先讲了RTP头部的意思，然后用代码显示头部的结构体。
2）然后针对SSRC、CSRC进行详解，具体可以先看3的pdf，然后再看png的例子，pdf的内容感觉他有部分SSRC和CSRC写错了，但是关系不大，整体
能听懂，结合3-png的SSRC、CSRC例子，然后看ZLM的RTP的相关代码(没有就百度相关文章)，看这两个字段如何填写的即可。
3）然后对时间戳字段进行详解。
4）强调seq序列号的重排需要缓冲队列进行排序，然后介绍丢包使用的方法，但并未讲该算法。
整体还是很容易听懂的，具体直接看代码即可，理论已经足够了。并且我博客也写了RTP的理论文章，不够看看就行，看这个资料就够了。

4-RTP之H264封包和解包1：
就讲了rtp如何封包的理论。具体看4的pdf、png，更重要的是看代码。

4-RTP之H264封包和解包2：
讲了项目里面的各个文件的作用和代码的大概意思。具体对着对应的4-png和pdf，最重要还是对着spec去看即可。
并且注意，他项目里面是使用单线程回调函数去实现的，并且用到static相关的变量、数组，例如main中就有，如果想改成多线程，必须注意这一点，
因为多线程共用一个同样的static必然容易保错。
他的建议：细节不用太关心，主要关注整个代码框架即可，因为细节的东西已经有很多成熟的实现，我们拷贝即可。
前面的1-4节重点：都是总结到了RTP04的png和代码，重写按着即可。

5 RTP之AAC的封包和解包：
1）本节重点讲了如何将aac封包为rtp以及如何解包rtp得到aac。
2）然后从代码可以学到，编码时seq、timestamp的处理以及解rtp包时对seq、timestamp的丢包检查使用。这两个看05-rtp的main总结。
3）并且看到代码中，如何对实际时间还没到已发送帧的总时间进行延时处理。这里使用了减去50好让客户端可以多缓存一到两帧。
4）总结了解rtp包成aac时，对应的重复包，乱序，丢包是如何处理的。包括C++和C语言的思路。本项目用的是C语言的思路。
	以后自己写的话建议优先选择C++的。具体看main的总结。
本项目的png需要看05-RTP之AAC的总结。

6 RTSP协议交互流程：
讲了RTSP协议推拉流的过程，非常简单和详细，按着6-PDF流程看即可。下面强调一下里面的sdp如何看(主要讲重点的字段)：
1）a代表会话中的属性，可以多个。
2）m代表媒体流的属性，一般分为视频流和音频流，他们都是m。并且注意该属性里面描述了音视频对应RTP的收流端口。
例如之前北京国标的问题，由于我们invite的时候发送的收流端口是0(livegbs的问题)，导致下级返回0而无法播放视频。但是这里的RTSP的推拉流的
RTP收流端口都是通过setup命令确认的，所以在ANNOUNCE或者DESCIRBE的sdp的m属性的端口是0也没关系，而国标的invite的sdp的收流端口则不行，
为0则无法观看音视频，个人是这样理解的。
图片可以看6-INVITE的图1图2。
3）最后，看sdp可以这样快速看：
	1. 视频流m属性一般都会带3个a属性，例如属性a1是rtpmap记录视频类型与时基单位。a2fmpt保存了sps，pps等内容。
		a3记录是streamid=0，表示是视频流的id，一般只有0和1,1代表音频流的id。
	2. 音频流m属性一般也都会带3个a属性。和视频流类似。
更多的字母缩写看pdf里面的那个链接，搜"Session Level description (Ref- RFC 4566 Section 5)"看即可。

4）注意一下推流时的ANNOUNCE后的响应会返回session给客户端，以及拉流时的DESCRIBE的响应也会返回对应的session给拉流客户端。
此后的命令都会使用该session。例如在setup中用于建立RTSP会话。

本节对着6-PDF流程(已看完)以及对应的抓包看是完全ok的，很简单。

7 SDP协议分析
比较简单，忘记SDP里面对应的字段的时候，看对应的pdf和png即可。

8 RTCP解析：
1）SR包的作用以及如何填写，重要的是如何填写里面的NTP。
2）
      2.1 SR包里面的一些时间戳，例如rtp_ts以及NTP。加上RTP包里面的时间戳后，如何转换出对应的可以用于音视频同步的时间戳。
	重要的是记住那条公式即可。
      2.2 以及简说RTCP包的一般发送间隔，即使用上面的公式的时候，必须转换成对应的单位再运算。
	
3）详说RTCP包的发送间隔及其相关条件。
4）可以不发RTCP包也能做音视频同步，重要是如何建立条件，让其音视频同步。
5）延伸RTSP拉流时，客户端发送PLAY命令后，服务器返回的npt(与上面的NTP不一样)、音视频各自的rtptime的作用。
6）最后可以看看RTCP的pdf，目前还没仔细看过。






9-1 RTSP推流实战-框架分析
主要讲了RTSP的推流框架流程，以及代码中一些类的作用。具体看9-1框架分析即可，已经重写总结了。

9-2 RTSP推流实战-模拟捕获音频
1）16min前讲了RTSP项目的讲课步骤，以及说了Common线程类和拷贝其它项目中的日志类在线程类中使用。
2）后面讲了audiocapture与pushwork两个类的编写。
3）并且在readPcmFile解释了为何音频不能提前采集(会导致重复)，而发送rtp可以提前发送的原因，两者是不一样的。readPcmFile的代码
也就是老师说的：如何控制播放速率。

9-3 RTSP推流实战-模拟捕获视频
    1. 和音频的设计一样，互相对比即可，并且后续可以将capture抽象出来一个类处理。
    2. 本节的亮点：
        1）开辟一帧的最大内存时，若分辨率是基数的话，宽高都需要各自加上1再互相乘以。
        2）同样是开辟一帧最大内存时，分辨率参数与乘以参数1.5不能写死，因为分辨率会变，1.5同样会变，1.5一般只是yuv420p格式才乘以这个倍数。
            音频同理，不会音频他后来改了一下，添加了format，默认s16，但是有部分参数还是写死了，例如通道数是2。
            反正后续重写时，必须使参数可变，不能写死。
        3）测试模式时和yuv文件的宽度一致，否则会出现各种问题。
        4）打印采集到首帧的时间戳(后续应该也会打印编码时、推流时的时间戳)，方便debug采集时、编码时、推流时的时间戳的延时对比。
        5）PushWork必须保证可以推多路流，每一路流互不影响。所以，若将分辨率写在ini配置，则会固定死每一路流的分辨率，而想要不同路流推不同分辨率时却无法做到，
            所以这是不允许的。

注：类是没有完全去回收数据的，后续需要自己完善一下，这里学习为主。
注：720x480_25fps_420p.yuv是非常大的，到达3.14G。。。RTMP的项目也要一个，可以删掉其中一个，当E盘内存不足的时候。

上面9-2与9-3都是看过完整代码并注释的，后面的没有完整看，直接看9-11即可。

9-4-1 RTSP推流实战-音频编码器
1）主要讲了音频编码器的封装类，内部实际使用FFmepg的codec去编码封装。
2）封装好编码器类后，讲了采集到的pcm数据后，在PushWork类的PushWork::PcmCallback需要重采样后才能送进编码器编码，编码完成后，添加adts
头，然后写入到文件当中(aac)，对比pcm文件，该aac文件是否能正常播放。  后续的重采样可以参考之前实现过的重采样器。
这一节后续可以不需要重复看，意义不大，看最后的rtsp的代码即可。

9-4-2 RTSP推流实战-音频编码器
1）优化上面的代码，实际主要对PushWork::PcmCallback进行优化。然后讲了PushWork类如何回收本类的资源。
2）并且释放的时候，由于main中的作用域导致PushWork调用析构，然后回收编码器audio_encoder_的时候，又在其类析构avcodec_free_context(&ctx_);
可以看到有两帧未冲刷出来(我这里是2帧)，"2 frames left in the queue on closing"，不过影响不大，后续优化一下即可，参考之前的项目，通过传参数
冲刷编码器即可。
3）本节不建议再看，意义也不大，看最后的rtsp的代码即可。

9-5 RTSP推流实战-视频编码器
1）与音频的设置风格一样，初始化时的一些注意点：
	1. gop的设置，设成与帧率一样即可，防止无法秒开。
	   例如帧率fps=25，那么gop=50，那么I帧间隔为2s。也就说若第1个I帧刚过，那么下一个I帧几乎需要2s才能刷新显示，所以秒开功能无法做到。
	2. 帧率与time_base，time_base设置成与帧率互为相反数即可，帧率一般是25。
	3. 若av_frame_get_buffer(frame_, 0)参2传0，则av_image_fill_arrays的末参不能写0，否则出现大小不等的错误，传1字节对齐即可。
	4. 初始化时，帧率不能写反，否则用mediaInfo查看fps时可以看到是0.04的帧率，明显不对的，25fps才是正确的。
	5. 设置preset与tune，保证零延时。
	其余也没什么了，大概都是按照音频去写，具体优化到时按照之前写的处理即可，例如08-02视频的项目。
2）本节不建议再看，意义也不大，看最后的rtsp的代码即可。

9-6 RTSP推流实战-队列设计
1）设计亮点：
	1. 队列设计需要支持超时、唤醒。
	2. 支持Drop掉队列中的数据，并且可以指定Drop一定数据，保留指定时长的数据。
	3. 音频、视频的总时长的计算是如何处理的，第一种是通过back_pts-front_pts得出，另一种是依靠用户传进的一帧时长duration*帧数得出，
		注意duration不能是FFmepg自己算出的即pkt->duration，它是依据pkt->pts算的，可能是0，所以需要的是用户传进的duration去算，
		不过还是建议使用back_pts-front_pts去算。
	4. 讲了Pop时的多线程的注意事项，本队列的场景是多个输入，单个线程输出的，所以他这样写不会存在问题，实际上包队列也是支持多个输出的。对比线程池的add设计，他是
		单个输入，多个线程输出的例子，而学cond时的类的例子是单线程输入包，单线程取包，这3者都是不一样的。
	线程池：https://blog.csdn.net/weixin_44517656/article/details/108691270。
	学cond时的类的例子：https://blog.csdn.net/weixin_44517656/article/details/112096777。
	5. 如何算队列的总时长，即第3点。并且对于GetAudioDuration、GetVideoDuration，因为以pts为准算duration，
		若pts出现小于0或者误差很大的情况，需要对duration进行纠正。
	6. 写了如何去drop只有视频包的情况，自己可以根据视频写出音频，应该不难，老师应该只是想让我们也思考一下。
		加上drop音频包的，Drop函数就支持了音视频包的drop了。
	7. 添加PopWithTimeout，只是改成了wait_for带超时的wait，后续可以将Pop内部的代码与PopWithTimeout内部代码写成一个函数，方便后续优化。
	上面的可以看对应9-6的png，里面总结了一些例子和总结。
2）本节不建议再看(对比上面9-1->9-5几节，本节看也可以)，意义也不大，看最后的rtsp的代码即可。

9-7 RTSP推流实战-RTSP推流模板(1）
1）封装了RtspPush推流的类，设计亮点：
	1. 内部需要另外开启线程去推流。
	2. 支持超时退出机制，例如支持连接服务器超时、往服务器发包超时的功能。
	3. 可以只推视频或者音频。
	4. 参数相关设置：
	   4.1 支持UDP或者TCP方式推流。
	   4.2 支持超时时间设置。
	   4.3 支持最大队列时长设置。
	5. pts的一些转换技巧。
2）流程大概按Init->Connect->ConfigVideoStream、ConfigAudioStream->sendPacket走的。
	实际就是对之前的项目的封装，也类似之前大华、海康推流的步骤。
3）本节不建议再看(对比上面9-1->9-5几节，本节看也可以)，意义也不大，看最后的rtsp的代码即可，相对我来讲还是比较简单的。
对应的9-7的png稍微看一下即可，不看也行，步骤都总结到这来来了。


9-8 RTSP推流实战-实现RTSP正常推流(1）
1）在PushWorker添加一些rtsppush相关的推流模块属性，并且在初始化时需要按照上面说的：
	先初始化编码模块，在初始化推流模块，最后才是采集模块。
2）然后跑通了基本的流程，但是在添加循环推多路流时，原在第一路结束后，第二路开始init的时候，服务器会返回406错误，
	原因是RtspPusher::Loop结束的时候没有write_trailer。添加后就不会出现该问题。
3）本项目的队列类的Drop函数还不支持Drop音频包的，因为我还没优化。
4）本节不建议再看(对比上面9-1->9-5几节，本节看也可以)，意义也不大，看最后的rtsp的代码即可。
5）并且本节留下一个下一节讲的问题：当connect一个不存在的rtsp地址时，在write_header会导致卡死，
	所以需要设置超时连接，超时连不上就返回，实际上这个问题在项目中就经常遇到，
	一般通过set字典参数或者传一个用户回调(记得当时好像是avformat_open_input也遇到卡死时，是用用户回调处理的)可以处理。
6）虽然音视频同步没有太大问题(只是不支持drop音频包，但是肯定是可以播放音频的)，
	不过这个项目还不是最好的，存在超时卡死和首帧模糊等bug情况，商业肯定是还不能使用，需要后续优化。
注：他这里的服务器用的是go写的easy达尔文。

9-9 RTSP推流实战-RTSP推流超时处理(1）
1）他使用了设置回调函数的方法处理超时。
2）并且验证了，当在推流过程中，断开流媒体服务器时，客户端在write_frame会出现：Broken pipe的错误。
	这种错误一般有很多原因，个人遇到就有：网络不好需要重连，或者网络断开实际就是服务器断开，
	这种处理可能可以重连一定次数后再把它断开。后续老师 说可以做成回调，以通知应用层PushWorker可以进行错误处理。
3）由于这节比较简单，我并未debug该项目，因为没太大必要，debug9-8就差不多了。

9-10 RTSP推流实战-消息处理机制(1）、也包括缓存队列的问题
1）讲了消息队列类的编写，以及在rtsppush添加缓存队列，如何检测packetQueue包队列，debug packetQueue包队列，
	根据网络情况(实际在项目好像一定时长去drop)去drop掉packetQueue包队列里面的音频、视频包。
	具体需要看代码，这节听得一般，不过看代码应该不存在问题。
2）该节的代码，老师写得有问题，然后视频就直接断了留在9-11综合优化处理了。
3）本节不建议再看，当然后续写博客(看是否有必要)有部分地方不明白的可以挑着看。

9-11 RTSP推流实战-综合优化
1）讲了上一节添加完缓存队列后，程序出现问题，原因是wait_for直接返回true了，可以对比本节代码与上一节的不同去看。
2）然后讲了packetQueue中的第一帧可能不是0的情况的front_pts的处理，处理完后back_pts也会出现问题，
	解决方法是使用duration去累计算，具体看代码，9-10的png也有讲，不过不是讲得很清晰。
3）该节代码已测试，udp、tcp、以及断开服务器后，程序都处理正常。

RTSP推流实战自我总结：
1）上面的每一节的代码都已经测试过没有问题，部分节没有测试说明不重要，无须测试。
2）后续9-11可以使用到对应的项目中，可以边使用边优化，优化肯定是跑不了的。
	老师也说到时候后续会继续优化以及用在播放器当中。
3）RTSP花的学习时间比较多，代码基本都是可以自己修改的，没有太多问题，后续就不需要花太多时间重学一遍。
4）并且换了一个Qt版本，从6/5.14换成5.10老师一样的版本，我是全部组件都下载了，
	但是没找到对应的msvc2017-32bit的编译器，虽然没找到，不过使用msvc2015-32bit的也可以
	进行debug，并且能查看到信息。
	至于为什么我电脑装了VS2017，有64bit但是找不到32bit，
	并且VS2015我没下载，但是msvc2015-32bit又能使用，我也不太清楚，反正就是qt存在的一些bug。
	我们能使用就行了。
这一点我是使用9-11 RTSP推流实战-综合优化的代码进行验证的，不过用的是mingw32bit(之前的也能用)，
在其它项目使用msvc2015-32bit也是能debug看到信息的，但是老是容易卡死，
而之前使用5.14或者qt6+cdb就是显示"表达式太复杂"的错误，连信息都看不到。
这就是msvc与mingw的区别，个人如果为了更好debug的话，尽量选择mingw，若msvc没问题则也可以选它。

